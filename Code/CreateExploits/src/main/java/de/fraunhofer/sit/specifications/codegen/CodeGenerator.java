package de.fraunhofer.sit.specifications.codegen;

import java.util.ArrayList;
import java.util.Base64;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.Phaser;
import java.util.Set;

import javax.naming.NameNotFoundException;

import de.fraunhofer.sit.specifications.attackinputs.BinaryDataParameter;
import de.fraunhofer.sit.specifications.attackinputs.EnvironmentVariable;
import de.fraunhofer.sit.specifications.attackinputs.EnvironmentVariables;
import de.fraunhofer.sit.specifications.attackinputs.Input;
import de.fraunhofer.sit.specifications.attackinputs.InputDataAssignment;
import de.fraunhofer.sit.specifications.attackinputs.InputParameter;
import de.fraunhofer.sit.specifications.attackinputs.OpenServerSocket;
import de.fraunhofer.sit.specifications.attackinputs.ReadFromServerSocket;
import de.fraunhofer.sit.specifications.attackinputs.RestartEnvironment;
import de.fraunhofer.sit.specifications.attackinputs.Run;
import de.fraunhofer.sit.specifications.attackinputs.StdIn;
import de.fraunhofer.sit.specifications.attackinputs.StringParameter;
import de.fraunhofer.sit.specifications.attackoutputs.Output;
import de.fraunhofer.sit.specifications.attackoutputs.OutputAsync;
import de.fraunhofer.sit.specifications.attackoutputs.StdErrAsync;
import de.fraunhofer.sit.specifications.attackpatterns.AttackPatternPreset;
import de.fraunhofer.sit.specifications.data.BinaryInputData;
import de.fraunhofer.sit.specifications.data.Data;
import de.fraunhofer.sit.specifications.data.StringInputData;
import de.fraunhofer.sit.specifications.executionprofile.ExecutionProfile;
import de.fraunhofer.sit.specifications.executionprofile.servletcontainers.ServletExecutionProfile;
import de.fraunhofer.sit.specifications.exploitcheckers.ExecutionDurationTimeout;
import de.fraunhofer.sit.specifications.exploitcheckers.SuccessfulExploitIndicator;
import de.fraunhofer.sit.specifications.testcases.TestCase;
import spoon.Launcher;
import spoon.refactoring.Refactoring;
import spoon.reflect.code.BinaryOperatorKind;
import spoon.reflect.code.CtAbstractInvocation;
import spoon.reflect.code.CtAssignment;
import spoon.reflect.code.CtBinaryOperator;
import spoon.reflect.code.CtBlock;
import spoon.reflect.code.CtCatch;
import spoon.reflect.code.CtComment.CommentType;
import spoon.reflect.code.CtCase;
import spoon.reflect.code.CtConstructorCall;
import spoon.reflect.code.CtExecutableReferenceExpression;
import spoon.reflect.code.CtExpression;
import spoon.reflect.code.CtFieldAccess;
import spoon.reflect.code.CtFieldRead;
import spoon.reflect.code.CtFieldWrite;
import spoon.reflect.code.CtFor;
import spoon.reflect.code.CtIf;
import spoon.reflect.code.CtInvocation;
import spoon.reflect.code.CtLiteral;
import spoon.reflect.code.CtLocalVariable;
import spoon.reflect.code.CtReturn;
import spoon.reflect.code.CtStatement;
import spoon.reflect.code.CtTry;
import spoon.reflect.code.CtTypeAccess;
import spoon.reflect.code.CtUnaryOperator;
import spoon.reflect.code.CtVariableAccess;
import spoon.reflect.code.UnaryOperatorKind;
import spoon.reflect.declaration.CtClass;
import spoon.reflect.declaration.CtCompilationUnit;
import spoon.reflect.declaration.CtConstructor;
import spoon.reflect.declaration.CtElement;
import spoon.reflect.declaration.CtField;
import spoon.reflect.declaration.CtMethod;
import spoon.reflect.declaration.CtType;
import spoon.reflect.declaration.ModifierKind;
import spoon.reflect.factory.Factory;
import spoon.reflect.reference.CtExecutableReference;
import spoon.reflect.reference.CtFieldReference;
import spoon.reflect.reference.CtTypeReference;
import spoon.reflect.visitor.CtScanner;
import spoon.support.reflect.code.CtFieldAccessImpl;

public class CodeGenerator {

	private TestCase testcase;
	public ExecutionProfile executionProfile;
	
	Launcher launcher = new Launcher();
	private Factory factory;
	
	public Factory getFactory() {
		return factory;
	}
	
	public Launcher getLauncher() {
		return launcher;
	}
	
	private CtType<?> clazzTarget;
	
	// defines environment parameters such as server host and port, paths for test files to use
	public InputDataAssignment environment;
	
	

	private AttackPatternPreset preset;

	private String className;


	private List<String> helperClasses;

	public CodeGenerator(TestCase t, ExecutionProfile executionProfile, AttackPatternPreset preset, InputDataAssignment environment, String className) {
		this.testcase = t;
		this.executionProfile = executionProfile;
		this.preset = preset;
		this.environment = environment;
		this.className = className;
		helperClasses = new ArrayList<String>();
	}

	
	public void addHelperClass(String executorClass) {
		helperClasses.add(executorClass);
	}
	
	@SuppressWarnings({ "rawtypes", "unchecked" })
	public GeneratedCode generate() {
		launcher.addInputResource("src/main/java/");
		launcher.run();
		Map<String, CtMethod> checkOutputMethodsCache = new HashMap<>();
		for (CtType<?> i : launcher.getModel().getAllTypes()) {
			if (i.getSimpleName().equals("Template")) {
				
				Refactoring.changeTypeName(i, className);
				clazzTarget = i;
				CtMethod<?> m = select(i.getMethodsByName("performExploits"));
				
				factory = clazzTarget.getFactory();
				
				executionProfile.generateCode(testcase, this);
				
				
				CtTypeReference<Boolean> booleantype = factory.Type().BOOLEAN_PRIMITIVE;
				CtTypeReference<Void> voidtype = factory.Type().VOID_PRIMITIVE;
				
				Set<CtTypeReference<? extends Throwable>> exceptions = new HashSet<>();
				exceptions.add(factory.createCtTypeReference(Exception.class));
				
				Set<ModifierKind> publicstatic = new HashSet<>();
				publicstatic.add(ModifierKind.PUBLIC);
				publicstatic.add(ModifierKind.STATIC);
				int initializeMethodCounter = 0;
				CtMethod<Void> initialize;//, processOutput;
				CtMethod<Boolean> performAttacks;
				List<CtMethod> initializeMethods = new ArrayList<>();
				
				CtType<Phaser> phaserType = factory.Type().get(Phaser.class);
				CtMethod<Object> arriveAwait = phaserType.getMethod("arriveAndAwaitAdvance");	
				CtMethod<Object> register = phaserType.getMethod("register");
				

				CtType<Object> threadClass = factory.Type().get(Thread.class);
				CtMethod<Object> sleep = threadClass.getMethod("sleep", factory.Type().LONG_PRIMITIVE);
				
				CtMethod<?> printStackTrace = factory.Type().get(Throwable.class).getMethod("printStackTrace");
				
				CtFieldReference<?> attackPhaser = clazzTarget.getDeclaredField("attackFinished");

				CtVariableAccess<?> phaserRef = factory.createVariableRead(attackPhaser, true);

				
				Map<SuccessfulExploitIndicator, CtMethod<Boolean>> outputCheckers = new HashMap<>();
				HashMap<Output, CtMethod<?>> processOutputMethods = new HashMap<>();
				
				// create checkOutput methods;
				{
					List<CtMethod<Boolean>> checkOutputMethods = new ArrayList<>();
					// TODO: consolidate checkOutput methods that do the same thing
					int checkOutputCount = 0;
					for (SuccessfulExploitIndicator checker : preset.successfulAttackIndicators) {
						CtMethod<Boolean> checkOutputMethod = checkOutputMethodsCache.get(checker.getTagName());
						// reuse existing implementation
						if (checkOutputMethod == null) {
							checker.generateCode(testcase, this);
							checkOutputMethod = (CtMethod<Boolean>) select(i.getMethodsByName("checkOutput"));
							Refactoring.changeMethodName(checkOutputMethod, "checkOutput" + checkOutputCount + checker.getTagName());
							checkOutputMethodsCache.put(checker.getTagName(), checkOutputMethod);
						}
						checkOutputMethods.add(checkOutputMethod);
						outputCheckers.put(checker, checkOutputMethod);
						
						if (i.getMethodsByName("initialize").size() > 0) {
							CtMethod<?> initMethod = select(i.getMethodsByName("initialize"));
							Refactoring.changeMethodName(initMethod, "initialize"+initializeMethodCounter);
							initializeMethods.add(initMethod);
							initializeMethodCounter++;
						}
						
						checkOutputCount++;
					}				
				
				}
				
				// create processOutput method
				{
					

					int processOutputCount = 0;
					for (Output out : testcase.outputs) {
						out.generateCode(testcase, this);
						CtMethod<Void> processOutputMethod = (CtMethod<Void>) select(i.getMethodsByName("processOutput"));
						Refactoring.changeMethodName(processOutputMethod, "processOutput" + processOutputCount + out.getTagName());
						processOutputMethods.put(out, processOutputMethod);
						
						if (i.getMethodsByName("initialize").size() > 0) {
							CtMethod<?> initMethod = select(i.getMethodsByName("initialize"));
							Refactoring.changeMethodName(initMethod, "initialize"+initializeMethodCounter);
							initializeMethods.add(initMethod);
							initializeMethodCounter++;
						}
						processOutputCount++;
					}
					
				}
				
				// create init method
				
				{
					CtBlock<?> initMethodBlock = factory.createBlock();
					for (CtMethod<?> initMethodX : initializeMethods) {
						CtExecutableReference<?> ref = initMethodX.getReference();
						 CtExecutableReferenceExpression<Object, CtExpression<Boolean>> exp = factory.createExecutableReferenceExpression();
						exp.setExecutable((CtExecutableReference<Object>) ref);
						initMethodBlock.addStatement(factory.createInvocation(factory.createTypeAccess(clazzTarget.getReference(), true), initMethodX.getReference()));
					}
					
					
					
					initialize = factory.createMethod((CtClass<?>) clazzTarget, publicstatic, voidtype, "initialize", new ArrayList<>(), exceptions, initMethodBlock);
					
					if (initializeMethods.size() > 1) {
						clazzTarget.addMethod(initialize);
					} else if (initializeMethods.size() == 1){
						initialize = initializeMethods.get(0);
					} else {
						initialize = null;
					}
				}
				
				// create attack code
				{
					

					
					
					List<CtMethod<?>> attackSteps = new ArrayList<>();
					HashMap<Input, CtMethod<?>> attackStepMethods = new HashMap<>();
					int attackStepCount = 0;
					for (Input in : testcase.inputs) {
						if (in instanceof RestartEnvironment) {
							CtMethod<?> attackMethod = select(i.getMethodsByName("startEnvironment"));							
							attackStepMethods.put(in, attackMethod);
							attackSteps.add(attackMethod);
							attackStepCount++;
							continue;
						}
						in.generateCode(testcase, this);
						CtMethod<?> attackMethod = select(i.getMethodsByName("attackStep"));
						Refactoring.changeMethodName(attackMethod, "attackStep" + attackStepCount + in.getTagName());
						if (in instanceof Run) {
							if (testcase.inputs.stream().anyMatch((input) -> (input instanceof OpenServerSocket)) ) {
								attackMethod.getBody().addStatement(factory.createInvocation(factory.createTypeAccess(threadClass.getReference()), sleep.getReference(), factory.createLiteral(500)));
							}
							if (!testcase.outputs.stream().anyMatch((output) -> (output instanceof StdErrAsync)) ) {
								attackMethod.getBody().addStatement(factory.createInvocation(factory.createTypeAccess(threadClass.getReference()), sleep.getReference(), factory.createLiteral(500)));
							}
						}
						attackStepMethods.put(in, attackMethod);
						attackSteps.add(attackMethod);
						attackStepCount++;
					}
					
					
					
					
					
					int attackCounter = 0;
					List<CtMethod<Boolean>> attackMethods = new ArrayList<>();
					for (InputDataAssignment inputData : preset.inputParameterAssignments) {
						for (InputParameter defaultParam : testcase.defaultVariables) {
							if (inputData.getParameter(defaultParam.id) == null) {
								inputData.add(defaultParam);
							}
						}
						CtBlock<?> attackBlock = factory.createBlock();
						
						
						if (initialize != null) {
							attackBlock.addStatement(factory.createInvocation(factory.createTypeAccess(clazzTarget.getReference(), true), initialize.getReference()));
						}
						
						CtBlock<?> attackstepsBlock = factory.createBlock();
						Map<Input, CtStatement> inputToAttackStepCall = new HashMap<>();
						for (Input in : testcase.inputs) {
							/*if (in instanceof RestartEnvironment) {

								CtMethod<?> startEnv = select(i.getMethodsByName("startEnvironment"));
								CtExecutableReference<?> ref = startEnv.getReference();
								CtInvocation<?> invocation = factory.createInvocation(factory.createTypeAccess(clazzTarget.getReference(), true), ref);
								attackstepsBlock.addStatement(invocation);
								continue;
							}*/
							CtMethod<?> attackStep = attackStepMethods.get(in);
							
							CtExecutableReference<?> ref = attackStep.getReference();
							 CtExecutableReferenceExpression<Object, CtExpression<Boolean>> exp = factory.createExecutableReferenceExpression();
							exp.setExecutable((CtExecutableReference<Object>) ref);
							
							//todo: allow byte[] parameters
							List<CtExpression<?>> args = createParameters(factory, attackBlock, inputData, in);
							CtInvocation<?> invocation = factory.createInvocation(factory.createTypeAccess(clazzTarget.getReference(), true), ref, args);
							inputToAttackStepCall.put(in, invocation);
							attackstepsBlock.addStatement(invocation);
							
						}
						
						// repeat attack steps if necessary
						if (preset.repeatInput != null) {
							CtFor forloop = factory.createFor();
							List<CtStatement> initStmts = new ArrayList<>();
							CtLocalVariable<Integer> loopvardecl = factory.createLocalVariable(factory.Type().INTEGER, "i", factory.createLiteral(0));
							forloop.setForInit(singleton(loopvardecl));
							CtUnaryOperator<Integer> inc = factory.createUnaryOperator();
							inc.setKind(UnaryOperatorKind.POSTINC);
							
							inc.setOperand(factory.createVariableRead(factory.createLocalVariableReference(loopvardecl), false));
							
							forloop.setForUpdate(singleton(inc));
							CtBinaryOperator<Boolean> lt = factory.createBinaryOperator();
							lt.setKind(BinaryOperatorKind.LT);
							lt.setLeftHandOperand(factory.createVariableRead(factory.createLocalVariableReference(loopvardecl), false));
							lt.setRightHandOperand(factory.createLiteral(preset.repeatInput.count));
							forloop.setExpression(lt);
							
							
							attackstepsBlock.addStatement(factory.createInvocation(factory.createTypeAccess(threadClass.getReference()), sleep.getReference(), factory.createLiteral(preset.repeatInput.delayms)));
							
							forloop.setBody(attackstepsBlock);
							attackBlock.addStatement(forloop);
							
						} else {
							while( attackstepsBlock.getStatements().size() > 0) {
								CtStatement st = attackstepsBlock.getStatement(0);
								attackstepsBlock.removeStatement(st);
								attackBlock.addStatement(st);
							}
						}
						
						// add processOutput methods
						
						for (Output processOutputX : testcase.outputs) {
							CtMethod<?> method = processOutputMethods.get(processOutputX);
							CtBlock<Object> processOutputBlock = factory.createBlock();
							List<CtExpression<?>> args = new ArrayList<>();
							if (processOutputX instanceof ITakesParameters) { 
								args = createParameters(factory, processOutputBlock, inputData, (ITakesParameters)processOutputX);
							}

							processOutputBlock.addStatement(factory.createInvocation(null, method.getReference(), args));
							
							if (processOutputX instanceof OutputAsync) {
								Input predInput = ((OutputAsync) processOutputX).getTriggeringInput(testcase.inputs);
								if (predInput != null) {
									CtStatement pred = inputToAttackStepCall.get(predInput);
									pred.insertAfter((CtStatement)processOutputBlock);
								} else {
									attackBlock.insertBegin((CtStatement)processOutputBlock);
								}
							} else {
								attackBlock.addStatement(processOutputBlock);
							}
						}
												
						// now return the result of the disjunction of all checkOutput calls
						CtExpression<Boolean> checkOutputDisjunction = null;
						for (Entry<SuccessfulExploitIndicator, CtMethod<Boolean>> kv : outputCheckers.entrySet()) {
							SuccessfulExploitIndicator checker = kv.getKey();
							CtMethod<Boolean> checkerFunction = kv.getValue();
							List<CtExpression<?>> args = createParameters(factory, attackBlock, inputData, checker);
							CtInvocation<Boolean> invocation = factory.createInvocation(null, checkerFunction.getReference()	, args);;
							if (checkOutputDisjunction == null) {
								checkOutputDisjunction = invocation;
							} else {
								checkOutputDisjunction = factory.createBinaryOperator(checkOutputDisjunction, invocation, BinaryOperatorKind.OR);
							}
						}
						
						
						
						attackBlock.insertBegin(factory.createInvocation(phaserRef, register.getReference()));
						CtConstructorCall exp = factory.createConstructorCall(phaserType.getReference());
						CtAssignment<Object, Object> cons = factory.createVariableAssignment(attackPhaser, true, exp);
						attackBlock.insertBegin(cons);
						
						if (preset.successfulAttackIndicators.stream().anyMatch(s -> (s instanceof ExecutionDurationTimeout))) {
							attackBlock.getLastStatement().addComment(factory.createComment(" collect output but don't wait for phaser lock. ", CommentType.INLINE));
						} else {
							attackBlock.addStatement(factory.createInvocation(phaserRef, arriveAwait.getReference()));
						}					
						

						// now wrap attack with try-catch
						// because of socket timeouts that occur if a servlet crashes
						// ( this happens often, i.e. if an sql statement is invalid )
						
						// try {
						//     attack() ...
						// } catch (Exception e) {
						//     e.printStackTrace();
						// } finally {
						//     try {
						//         return checkOutput(...);
						//     } catch (Exception e) {
						//         return false;
						//     }
						// }
						
						CtTry t = factory.createTry();
						t.setBody(attackBlock);

						
						
						CtTry tryCheckOutput = factory.createTry();
						
						
						CtBlock<?> returnCheckBlock = factory.createBlock();
						
						CtReturn<Boolean> returnCheckOutput = factory.createReturn();
						returnCheckOutput.setReturnedExpression(checkOutputDisjunction);
						returnCheckBlock.addStatement(returnCheckOutput);
						
						tryCheckOutput.setBody(returnCheckBlock);
						
						CtBlock<?> catchCheckOutput = factory.createBlock();
						CtReturn<Object> returnFalse = factory.createReturn();
						returnFalse.setReturnedExpression(factory.createLiteral(false));
						
						
						CtCatch catcherCheckOutput = factory.createCtCatch("ee", Exception.class, catchCheckOutput);
						
						catchCheckOutput.addStatement(factory.createInvocation(factory.createVariableRead(catcherCheckOutput.getParameter().getReference(), false), printStackTrace.getReference()));

						catchCheckOutput.addStatement(returnFalse);
						
						tryCheckOutput.addCatcher(catcherCheckOutput);
						

						CtBlock<?> finallyBlock = factory.createBlock();
						finallyBlock.addStatement(tryCheckOutput);
						t.setFinalizer(finallyBlock);
						
						CtBlock<?> catchBlock = factory.createBlock();
						
						CtCatch c = factory.createCtCatch("e", Throwable.class, catchBlock);
						t.addCatcher(c);
						catchBlock.addStatement(factory.createInvocation(factory.createVariableRead(c.getParameter().getReference(), false), printStackTrace.getReference()));
						
						
						CtBlock<?> wrappedAttackBlock = factory.createBlock();
						wrappedAttackBlock.addStatement(t);
						
						
						
						CtMethod attackMethodX = factory.createMethod((CtClass<?>) clazzTarget, publicstatic, booleantype, "attack"+attackCounter, new ArrayList<>(), new HashSet<>(), wrappedAttackBlock);
						attackMethods.add(attackMethodX);
						clazzTarget.addMethod(attackMethodX);
						
						attackCounter ++;
						
						
					}
					
					{
						CtBlock<?> performAllAttacksBlock = factory.createBlock();
						for (CtMethod<Boolean> attackX : attackMethods) {
							CtExecutableReference<?> ref = attackX.getReference();
							 CtExecutableReferenceExpression<Object, CtExpression<Boolean>> exp = factory.createExecutableReferenceExpression();
							exp.setExecutable((CtExecutableReference<Object>) ref);
							CtIf ifSt = factory.createIf();
							ifSt.setCondition(factory.createInvocation(null, attackX.getReference()));
							CtReturn<Object> returnTrue = factory.createReturn();
							returnTrue.setReturnedExpression(factory.createLiteral(true));
							ifSt.setThenStatement(returnTrue);
							performAllAttacksBlock.addStatement(ifSt);
						}
						
						
						CtReturn<Object> returnFalse = factory.createReturn();
						returnFalse.setReturnedExpression(factory.createLiteral(false));
						performAllAttacksBlock.addStatement(returnFalse);
						
						performAttacks = factory.createMethod((CtClass<?>) clazzTarget, publicstatic, booleantype, "performExploits", new ArrayList<>(), new HashSet<>(), performAllAttacksBlock);
						clazzTarget.addMethod(performAttacks);
					}
				}

				String prettyCode = i.toString().replace("de.fraunhofer.sit.specifications.PatternExploitChecker.", "");
				prettyCode = prettyCode.replace(i.getQualifiedName()+".", "");
				GeneratedCode generatedCode = new GeneratedCode(className, prettyCode	);
				generatedCode.helperClasses = this.helperClasses; 
				
				return generatedCode;
			}
		}
		return null;
	}
	
	private void insertAfter(CtBlock block, CtStatement stmt, CtStatement newStmt) {
		int index = block.getStatements().indexOf(stmt);
		if (index == -1) {
			throw new RuntimeException("Trying to insert after nonexistent statement");
		}
		block.addStatement(index + 1, newStmt);
	}
	
	private <T> List<T> singleton(T x) {
		ArrayList<T> l = new ArrayList<>();
		l.add(x);
		return l;
	}
	
	/**
	 * @param block
	 * @param varName
	 * @return true if there a variable with id varName is declared in this block
	 */
	private boolean blockDeclaresVariable(CtBlock<?> block, String varName) {
		for (CtStatement s : block.getStatements()) {
			if (s instanceof CtLocalVariable) {
				CtLocalVariable<?> localvar = (CtLocalVariable<?>) s;
				if (localvar.getSimpleName().equals(varName)) {
					return true;
				}
				
			}
		}
		return false;
	}

	@SuppressWarnings("rawtypes")
	private List<CtExpression<?>> createParameters(Factory factory, CtBlock<?> block, InputDataAssignment inputData, ITakesParameters in) {
		CtMethod<?> convert = select(clazzTarget.getMethodsByName("toPrimitive"));
		List<CtExpression<?>> args = new ArrayList<>();
		List<Object> parameterValues = in.getParameterValues();
		for (int a = 0; a < parameterValues.size(); a++) {
			Object arg = parameterValues.get(a);
			if (arg == null){ 
				args.add(factory.createLiteral((Object)null));
			} else if (arg instanceof Integer) { 
				Integer val = (Integer) arg;
				args.add(factory.createLiteral(val));
			} else if (arg instanceof Long) { 
				Long val = (Long) arg;
				args.add(factory.createLiteral(val));
			} else if (arg instanceof Boolean) { 
				Boolean val = (Boolean) arg;
				args.add(factory.createLiteral(val));
			} else if (arg instanceof String) { 
				String val = (String) arg;
				String param = inputData.replaceVariablesInString(val, in.shouldURLEncodeParameter(a));
				param = environment.replaceVariablesInString(param, in.shouldURLEncodeParameter(a));
				args.add(factory.createLiteral(param));
			} else if (arg instanceof HashMap) {
				// fill in hashmap values
				int i = 0; 
				String mapname = "map";
				while (blockDeclaresVariable(block, mapname)) {
					i++;
					mapname = "map" + i;
				}
				CtClass<Object> hashMapClass = (CtClass<Object>) factory.Type().get(HashMap.class);
				CtConstructorCall exp = factory.createConstructorCall(hashMapClass.getReference());
				List<CtTypeReference<?>> typeArgs = new ArrayList<CtTypeReference<?>>();
				typeArgs.add(factory.Type().stringType());
				typeArgs.add(factory.Type().stringType());
				exp.setActualTypeArguments(typeArgs);
				CtTypeReference<Map> mapType = factory.Type().createReference(Map.class);
				mapType.setActualTypeArguments(typeArgs);
				CtLocalVariable varDecl = factory.createLocalVariable(mapType, mapname, exp);
				block.addStatement(varDecl);
				CtMethod<Object> put = hashMapClass.getMethod("put", hashMapClass.getFormalCtTypeParameters().get(0).getReference(),hashMapClass.getFormalCtTypeParameters().get(0).getReference());
				
				for (Entry<String,Object> kv : ((HashMap<String,Object>)arg).entrySet()) {
					String key = kv.getKey();
					key = inputData.replaceVariablesInString(key, in.shouldURLEncodeParameter(a));
					key = environment.replaceVariablesInString(key, in.shouldURLEncodeParameter(a));
					Object val = kv.getValue();
					if (val instanceof String) {
						val = inputData.replaceVariablesInString((String) val, in.shouldURLEncodeParameter(a));
						val = environment.replaceVariablesInString((String) val, in.shouldURLEncodeParameter(a));
					}
					CtLiteral<String> keyLiteral = factory.createLiteral(key);
					CtLiteral<Object> valLiteral = factory.createLiteral(val);
					block.addStatement(factory.createInvocation(factory.createVariableRead(varDecl.getReference(), true) , put.getReference(), keyLiteral, valLiteral));
				}
				args.add(factory.createVariableRead(varDecl.getReference(), true));
			} else if (arg instanceof StringInputData) {
				String val = ((StringInputData) arg).getValue();
				val = inputData.replaceVariablesInString((String) val, in.shouldURLEncodeParameter(a));
				val = environment.replaceVariablesInString((String) val, in.shouldURLEncodeParameter(a));
				CtClass stringClass = (CtClass) factory.Type().get(String.class);
				CtMethod<Object> getBytes = stringClass.getMethod("getBytes");
				args.add(factory.createInvocation(factory.createLiteral(val), getBytes.getReference()));
			} else if (arg instanceof BinaryInputData) {
				String id = ((BinaryInputData) arg).getId();
				InputParameter param = inputData.getParameter(id);
				if (param != null && param instanceof BinaryDataParameter) {
					byte[] data = ((BinaryDataParameter) param).getData();
					Byte[] byteData = new Byte[data.length];
					for (int i = 0; i < data.length; i++) {
						byteData[i] = data[i];
					}
					args.add(factory.createInvocation(null, convert.getReference(),  factory.createLiteralArray(byteData)));
				} else if (param != null && param instanceof StringParameter) {
					// better than nothing: just plug string data.
					String val = ((StringParameter)param).value;
					byte[] data = (val).getBytes();
					Byte[] byteData = new Byte[data.length];
					for (int i = 0; i < data.length; i++) {
						byteData[i] = data[i];
					}
					args.add(factory.createInvocation(null, convert.getReference(),  factory.createLiteralArray(byteData)));
				}else {
					throw new RuntimeException("Undefined binary data: " + id);
				}
			} 
			else {
				throw new RuntimeException("illegal attack step argument type");
			}
		}
		return args;
	}

	private static <T> T select(List<T> l) {
		if (l.isEmpty())
			throw new IllegalArgumentException("Empty");
		if (l.size() > 1)
			throw new IllegalArgumentException("More than one element: " + l);
		return l.get(0);
	}

	/**
	 * @param cz class to merge
	 * @param fieldRenames insert and rename fields from cz
	 */
	public void merge(Class<?> cz, Map<String, String> fieldRenames) {
		merge(cz, fieldRenames, new HashMap<>());
	}
	/**
	 * @param cz class to merge
	 * @param fieldRenames insert and rename fields from cz
	 * @param stringSubstitutions substitute string literals
	 */
	public void merge(Class<?> cz, Map<String, String> fieldRenames, Map<String, String> stringSubstitutions) {

		
		CtType<?> type = getClass(cz);
		
		// copy fields to exploit class
		// rename the field if specified
		// don't add if it already exists
		Map<String, CtFieldReference<?>> fields = new HashMap<>();
		for (CtField<?> f : type.getFields()) {
			String newName = fieldRenames.get(f.getSimpleName());
			if (newName != null) {
				f.setSimpleName(newName);
			}
			CtFieldReference existingField = clazzTarget.getDeclaredField(f.getSimpleName());
			if (existingField == null) {
				clazzTarget.addField(f);
				fields.put(f.getSimpleName(), f.getReference());
			} else {
				fields.put(f.getSimpleName(), existingField);
			}
			
		}
		fieldRenames.put("attackFinished", "attackFinished");
		fields.put("attackFinished", clazzTarget.getDeclaredField("attackFinished"));
		for (CtMethod<?> m : type.getMethods()) {
			CtMethod<?> copy = m;
			
			if (copy.getDocComment() != null && copy.getDocComment().contains("placeholder"))
				continue;
			
			clazzTarget.addMethod(copy);
			Factory factory = copy.getFactory();
			// rename field references in this method
			//TODO: convert filedread to loacalvariableaccess with static=true
			copy.accept(new CtScanner() {
				
				@Override
				public <T> void visitCtFieldRead(CtFieldRead<T> fieldRead) {
					String newName = fieldRenames.get(fieldRead.getVariable().getSimpleName());
					if (newName != null) {
						// we are accessing a field that was renamed.
						// redirect reference
						CtFieldReference r = fields.get(newName);
						
						fieldRead.setVariable(r.clone());
						fieldRead.setTarget(factory.createTypeAccess(clazzTarget.getReference()));
					}
					
				}
				
				@Override
				public <T> void visitCtFieldWrite(CtFieldWrite<T> fieldWrite) {
					String newName = fieldRenames.get(fieldWrite.getVariable().getSimpleName());
					if (newName != null) {
						// we are accessing a field that was renamed.
						// redirect reference
						CtFieldReference r = fields.get(newName);
						fieldWrite.setVariable(r.clone());
						fieldWrite.setTarget(factory.createTypeAccess(clazzTarget.getReference()));
					}
				}
				
				@Override
				public <T> void visitCtLiteral(CtLiteral<T> literal) {
					Object val = literal.getValue();
					if (val instanceof String) {
						String replacement = stringSubstitutions.get(val);
						if (replacement != null) {
							((CtLiteral)literal).setValue(replacement);
						}
					}
				}
				
			});

			for (CtElement st : copy.getBody().asIterable()) {
				
				if (st instanceof CtLocalVariable) {
					CtLocalVariable v = (CtLocalVariable) st;
					if (v.getType().getQualifiedName().startsWith("de.fraunhofer.sit.specifications")) {
						CtType<?> nested = clazzTarget.getNestedType(v.getType().getSimpleName());
						v.setType(nested.getReference());
						if (v.getDefaultExpression() instanceof CtAbstractInvocation) {
							CtAbstractInvocation exp = (CtAbstractInvocation) v.getDefaultExpression();
							CtExecutableReference r = exp.getExecutable();
							r.setDeclaringType(nested.getReference());
							r.setType(nested.getReference());
							exp.setExecutable(r);
						}
					}
				}
				if (st instanceof CtInvocation) {
					CtInvocation inv = (CtInvocation) st;
					CtExecutableReference e = inv.getExecutable();
					if (e.getDeclaringType().equals(type.getReference())) {
						CtTypeAccess ct = (CtTypeAccess) inv.getTarget();
						ct.setAccessedType(clazzTarget.getReference());
						e.setDeclaringType(clazzTarget.getReference());
						// inv.setTarget(clazzTarget.getReference());
					}
				}
				
				if (st instanceof CtLiteral) {
					CtLiteral str = (CtLiteral) st;
					if (str.getValue() instanceof String) {
						
					}
				}

			}
		}
	}

	private CtType<?> getClass(Class<?> cz) {
		return getClass(cz.getTypeName());
	}

	private CtType<?> getClass(String typeName) {

		for (CtType<?> i : launcher.getModel().getAllTypes()) {
			if (i.getQualifiedName().equals(typeName)) {
				return i;
			}
			for (CtType<?> n : i.getNestedTypes()) {
				if (n.getQualifiedName().equals(typeName))
					return n;
			}
		}
		return null;
	}


	public void addInnerClass(Class<?> cl) {
		CtType<?> c = getClass(cl);
		CtType<?> r = c.clone();
		clazzTarget.addNestedType(r);
		// redirect field references to new type
		for (CtMethod<?> m : r.getAllMethods()) {
			for (CtElement st : m.getBody().asIterable()) {
				if (st instanceof CtFieldAccessImpl) {
					System.out.println(st);
					((CtFieldAccessImpl) st).setTarget(factory.createThisAccess(r.getReference()));
				}

			}
		}
	}

}
