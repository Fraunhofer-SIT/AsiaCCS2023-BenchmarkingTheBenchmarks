package de.fraunhofer.sit.specifications.exploitcheckers;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import org.apache.commons.lang3.StringEscapeUtils;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.TextNode;
import org.jsoup.select.NodeTraversor;
import org.jsoup.select.NodeVisitor;
import org.w3c.dom.Node;

import de.fraunhofer.sit.specifications.attackpatterns.Presets;
import de.fraunhofer.sit.specifications.codegen.CodeGenerator;
import de.fraunhofer.sit.specifications.codegen.IGenerateCode;
import de.fraunhofer.sit.specifications.testcases.TestCase;
import de.fraunhofer.sit.specifications.util.XMLUtils;

public class UnescapedHTMLExploitChecker extends SuccessfulExploitIndicator implements IGenerateCode {

	public String pattern;
	// implicitly always check program output.
	
	public String reference;



	private static class RemoveVisitor implements NodeVisitor {

		private boolean isInScriptTag;
		private Set<org.jsoup.nodes.Node> toRemove = new HashSet<>();

		@Override
		public void head(org.jsoup.nodes.Node node, int depth) {
			String name = node.nodeName();
			if (node instanceof TextNode) {
				if (!isInScriptTag) {
					toRemove.add(node);
				}
			} else if (name.equals("script")) {
				isInScriptTag = true;
			}
		}

		@Override
		public void tail(org.jsoup.nodes.Node node, int depth) {
			String name = node.nodeName();
			if (name.equals("script"))
				isInScriptTag = false;
		}

		public void remove() {
			for (org.jsoup.nodes.Node i : toRemove)
				i.remove();
		}
	}

	public static class TemplateHTML {
		
		static String programOutput = "";
		
		public static String preprocess(String input) {
			String s = org.jsoup.Jsoup.clean(input, org.jsoup.safety.Whitelist.relaxed().addTags("script"));
			Document doc = Jsoup.parse(s);
			RemoveVisitor rm = new RemoveVisitor();
			NodeTraversor.traverse(rm, doc);
			rm.remove();
			return doc.toString();

		}
		


		public static boolean checkOutput(String pattern) throws IOException {
			String escaped = preprocess(programOutput);
			System.out.println("[OutputContainsUnescapedHTML] unescaped html: " + escaped + " [END]");
			System.out.println("[OutputContainsUnescapedHTML] checking for \"" + pattern + "\"");
			return (escaped.contains(pattern));
		}


		public static boolean checkForRegex(String regex, String value) throws IOException {
			return java.util.regex.Pattern.compile(regex).matcher(value).matches();
		}

		public static boolean checkContains(String pattern, String value) throws IOException {
			return value.contains(pattern);
		}
	}
	

	@Override
	public void generateCode(TestCase testcase, CodeGenerator generator) {
		Class<?> c = TemplateHTML.class;
		generator.addInnerClass(RemoveVisitor.class);
		generator.merge(c, getFieldRenames());

	}

	@Override
	public String getTagName() {
		return "OutputContainsUnescapedHTML";
	}

	@Override
	public void readIn(Node node) {
		reference = XMLUtils.getAttributeValue(node, "reference", "programOutput");
		pattern = node.getTextContent();
	}
	@Override
	public Map<String, String> getFieldRenames() {
		Map<String, String> fields = new HashMap<>();
		fields.put("programOutput", reference);
		return fields;
	}

	@Override
	public List<Object> getParameterValues() {
		List<Object> params = new ArrayList<>();
		params.add(pattern);
		return params;
	}
	
}
