package de.fraunhofer.sit.specifications.exploitcheckers;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;

import org.w3c.dom.Node;

import de.fraunhofer.sit.specifications.codegen.CodeGenerator;
import de.fraunhofer.sit.specifications.testcases.TestCase;
import de.fraunhofer.sit.specifications.util.XMLUtils;

public class ExecutionDurationTimeout extends SuccessfulExploitIndicator {
	public int timeout;
	public static class Template {

		static Process process0;

		public static boolean checkOutput(int seconds) throws Exception {
			System.out.println("[EXECUTIONDURATIONTIMEOUT] Waiting " + seconds + "seconds.");
			// wait for the timeout
			Thread.sleep(seconds * 1000);
			// if the process is still running, our condition is met.
			if  (process0.isAlive()) {
				process0.destroyForcibly();
				System.out.println("[EXECUTIONDURATIONTIMEOUT] Process is still running. Timeout detected.");

				return true;
			} else {
				System.out.println("[EXECUTIONDURATIONTIMEOUT] Process has terminated. no timeout");

				return false;
			}
		}

	
	}

	@Override
	public void generateCode(TestCase testcase, CodeGenerator generator) {
		generator.merge(Template.class, getFieldRenames());
	}

	@Override
	public String getTagName() {

		return "ExecutionDurationTimeout";
	}

	@Override
	public void readIn(Node node) {
		timeout = Integer.valueOf(XMLUtils.getAttributeValue(node, "timeout"));
	}

	@Override
	public Map<String, String> getFieldRenames() {
		Map<String, String> fields = new HashMap<>();
		fields.put("process0", "process0");
		return fields;
	}

	@Override
	public List<Object> getParameterValues() {
		List<Object> params = new ArrayList<>();
		params.add(timeout);
		return params;
	}
	

}
