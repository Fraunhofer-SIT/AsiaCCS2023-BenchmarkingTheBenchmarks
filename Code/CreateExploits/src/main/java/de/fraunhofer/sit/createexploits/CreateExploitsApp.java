package de.fraunhofer.sit.createexploits;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.servlet.http.Cookie;
import javax.tools.JavaCompiler;
import javax.tools.ToolProvider;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.apache.commons.io.FileUtils;
import org.apache.maven.shared.invoker.SystemOutHandler;
import org.w3c.dom.Node;

import de.fraunhofer.sit.specifications.attackinputs.ConnectToRemoteSocket;
import de.fraunhofer.sit.specifications.attackinputs.DatabaseInput;
import de.fraunhofer.sit.specifications.attackinputs.InputDataAssignment;
import de.fraunhofer.sit.specifications.attackinputs.LoadLibrary;
import de.fraunhofer.sit.specifications.attackinputs.OpenServerSocket;
import de.fraunhofer.sit.specifications.attackinputs.ReadFromURL;
import de.fraunhofer.sit.specifications.attackoutputs.DatabaseOutput;
import de.fraunhofer.sit.specifications.attackoutputs.ExecutesBinary;
import de.fraunhofer.sit.specifications.attackoutputs.WriteToRemoteSocket;
import de.fraunhofer.sit.specifications.attackoutputs.WriteToServerSocket;
import de.fraunhofer.sit.specifications.attackpatterns.AttackPattern;
import de.fraunhofer.sit.specifications.attackpatterns.AttackPatternPreset;
import de.fraunhofer.sit.specifications.attackpatterns.Presets;
import de.fraunhofer.sit.specifications.codegen.CodeGenerator;
import de.fraunhofer.sit.specifications.codegen.GeneratedCode;
import de.fraunhofer.sit.specifications.executionprofile.ExecutionProfile;
import de.fraunhofer.sit.specifications.executionprofile.servletcontainers.ServletExecutionProfile;
import de.fraunhofer.sit.specifications.executionprofile.testsuite.JulietTestsuite;
import de.fraunhofer.sit.specifications.executionprofile.testsuite.OWASPTestsuite;
import de.fraunhofer.sit.specifications.testcases.TestCase;
import de.fraunhofer.sit.specifications.testcases.TestCaseSource;
import de.fraunhofer.sit.specifications.util.ParallelBase;
import de.fraunhofer.sit.specifications.util.ParallelBase.ParallelOperation;
import de.fraunhofer.sit.specifications.util.ParseModels;

public class CreateExploitsApp {

	// where to store classes that perform exploits
	public static File testCodeSrcDir = new File("../RunExploits/src/main/java");

	public static File dockercontainerParentDir = new File("../Containers/");

	// where to store classes that are exploited, including wrapper classes
	public static File vulnerableCodeSrcDir = new File("../VulnerableCode/src/main/java");

	// where to store proof of vulnerability image
	public static File containerDir = new File("../Containers");

	private static boolean strict = false;
	public static String[] tested = new String[] {
	"CWE470_Unsafe_Reflection__Property_81_bad",
	"CWE83_XSS_Attribute__Servlet_listen_tcp_03_bad"
	,"CWE23_Relative_Path_Traversal__getParameter_Servlet_08_bad"
	,"CWE78_OS_Command_Injection__PropertiesFile_81_bad"
	,"CWE89_SQL_Injection__listen_tcp_executeUpdate_81_good"
	,"CWE23_Relative_Path_Traversal__getQueryString_Servlet_21_bad"
	,"OWASP_00459"
	,"CWE89_SQL_Injection__listen_tcp_prepareStatement_75_bad"
	,"OWASP_02531"
	,"OWASP_00541"
	,"CWE23_Relative_Path_Traversal__Property_41_bad"
	,"CWE36_Absolute_Path_Traversal__database_07_bad"
	,"CWE23_Relative_Path_Traversal__URLConnection_72_bad"
	,"CWE83_XSS_Attribute__Servlet_getQueryString_Servlet_16_bad"
	,"OWASP_00695"
	,"CWE113_HTTP_Response_Splitting__database_addCookieServlet_01_bad"
	,"CWE113_HTTP_Response_Splitting__File_addCookieServlet_21_bad"
	,"OWASP_02631"
	,"OWASP_00193"
	,"CWE80_XSS__CWE182_Servlet_File_71_bad"
	,"OWASP_00152"
	,"CWE89_SQL_Injection__getQueryString_Servlet_executeBatch_45_bad"
	,"CWE319_Cleartext_Tx_Sensitive_Info__send_01_bad"
	,"CWE319_Cleartext_Tx_Sensitive_Info__connect_tcp_driverManager_01_bad" 
	,"CWE114_Process_Control__basic_02_bad" 
	,"CWE382_Use_of_System_Exit__Servlet_System_01_bad"
	,"CWE835_Infinite_Loop__do_01_bad" 
	,"CWE598_Information_Exposure_QueryString__Servlet_04_good" 
	,"CWE598_Information_Exposure_QueryString__Servlet_04_bad" 
	,"CWE511_Logic_Time_Bomb__time_01_bad" 
	,"CWE510_Trapdoor__hostname_based_logic_01_bad" 
	,"CWE510_Trapdoor__ip_based_logic_01_bad"
	,"CWE78_OS_Command_Injection__Environment_22_bad" 
	,"CWE400_Resource_Exhaustion__sleep_File_72_good" 
	,"CWE400_Resource_Exhaustion__sleep_File_72_bad" 
	,"CWE601_Open_Redirect__Servlet_database_13_bad" 
	,"CWE400_Resource_Exhaustion__PropertiesFile_write_21_bad"
	,"CWE400_Resource_Exhaustion__URLConnection_write_68_bad"
	,"CWE789_Uncontrolled_Mem_Alloc__heap_08_bad" 
	,"CWE81_XSS_Error_Message__Servlet_File_15_bad" 
	,"CWE90_LDAP_Injection__URLConnection_67_bad" 
	,"CWE23_Relative_Path_Traversal__connect_tcp_01_bad"
	,"CWE23_Relative_Path_Traversal__listen_tcp_81_bad"
	,"CWE400_Resource_Exhaustion__console_readLine_write_42_bad"
	,"CWE80_XSS__CWE182_Servlet_getParameter_Servlet_51_bad"
	,"CWE789_Uncontrolled_Mem_Alloc__getQueryString_Servlet_HashMap_22_bad",
	"CWE606_Unchecked_Loop_Condition__console_readLine_68_bad",
	"CWE601_Open_Redirect__Servlet_PropertiesFile_41_bad",
	"CWE80_XSS__CWE182_Servlet_database_31_bad",
	"CWE789_Uncontrolled_Mem_Alloc__getQueryString_Servlet_ArrayList_31_bad",
	"OWASP_02177",
	"CWE315_PlainteCWE113_HTTP_Response_SplittingCWE113_HTTP_Response_Splittingxt_Storage_in_Cookie__Servlet_31_bad",
	"OWASP_00630",
	"CWE83_XSS_Attribute__Servlet_database_81_bad",
	"CWE400_Resource_Exhaustion__sleep_Environment_73_bad",
	"CWE89_SQL_Injection__connect_tcp_executeQuery_10_bad",
	"CWE601_Open_Redirect__Servlet_database_67_bad",
	"CWE23_Relative_Path_Traversal__getQueryString_Servlet_21_bad",
	"CWE89_SQL_Injection__getQueryString_Servlet_executeQuery_09_bad",
	"CWE89_SQL_Injection__getCookies_Servlet_executeQuery_13_bad",
	"CWE80_XSS__CWE182_Servlet_getQueryString_Servlet_81_bad",
	"OWASP_02177",
	"CWE113_HTTP_Response_Splitting__database_addCookieServlet_66_bad",
	"CWE23_Relative_Path_Traversal__Property_41_bad",
	"CWE113_HTTP_Response_Splitting__getParameter_Servlet_addHeaderServlet_42_bad",
	"CWE113_HTTP_Response_Splitting__PropertiesFile_addCookieServlet_81_bad",
	"CWE113_HTTP_Response_Splitting__Environment_setHeaderServlet_05_bad",
	"CWE80_XSS__CWE182_Servlet_getParameter_Servlet_51_bad",
	"CWE23_Relative_Path_Traversal__Environment_31_bad",
	"CWE89_SQL_Injection__database_executeBatch_11_bad",
	"CWE113_HTTP_Response_Splitting__console_readLine_addCookieServlet_01_bad",
	"CWE113_HTTP_Response_Splitting__Environment_addCookieServlet_71_bad",
	"CWE400_Resource_Exhaustion__random_for_loop_66_bad",
	"OWASP_00525",
	"OWASP_02109",
	"OWASP_02305",
	"OWASP_02177",
	"OWASP_02196",
	"OWASP_00457",
	"OWASP_00433",
	"OWASP_02037",
	"OWASP_00630",
	"OWASP_01673",
	"OWASP_01430",
	"OWASP_00021",
	"CWE90_LDAP_Injection__connect_tcp_81_bad",
	"CWE80_XSS__CWE182_Servlet_PropertiesFile_75_bad",
	"OWASP_02299",
	"OWASP_02177",
	"OWASP_01988",
	"OWASP_00006",
	"OWASP_00996",
	"OWASP_00433",
	"CWE113_HTTP_Response_Splitting__Property_setHeaderServlet_51_bad",
	"CWE89_SQL_Injection__getQueryString_Servlet_executeQuery_09_bad",
	"CWE83_XSS_Attribute__Servlet_connect_tcp_17_bad",
	"CWE89_SQL_Injection__getQueryString_Servlet_executeQuery_09_bad",
	"CWE83_XSS_Attribute__Servlet_connect_tcp_17_bad",
	"CWE81_XSS_Error_Message__Servlet_database_01_bad",
	"CWE36_Absolute_Path_Traversal__database_07_bad",
	"OWASP_01395",
	"CWE549_Missing_Password_Masking__Servlet_08_bad",
	"OWASP_00040",
	"CWE113_HTTP_Response_Splitting__PropertiesFile_setHeaderServlet_11_bad",
	"CWE23_Relative_Path_Traversal__Environment_06_bad",
	"CWE526_Info_Exposure_Environment_Variables__Servlet_10_bad",
	"CWE80_XSS__Servlet_URLConnection_21_bad",
	"CWE23_Relative_Path_Traversal__File_01_bad",
	"CWE400_Resource_Exhaustion__Servlet_13_bad",
	"CWE400_Resource_Exhaustion__sleep_File_72_bad",
	"CWE400_Resource_Exhaustion__File_for_loop_74_bad",
	"CWE470_Unsafe_Reflection__File_09_bad",
	"CWE510_Trapdoor__ip_based_logic_09_bad",
	"CWE601_Open_Redirect__Servlet_File_81_bad",
	"CWE606_Unchecked_Loop_Condition__File_52_bad",
	"CWE789_Uncontrolled_Mem_Alloc__File_ArrayList_10_bad",

	"CWE23_Relative_Path_Traversal__File_01_bad",
	"CWE90_LDAP_Injection__File_16_bad",
	"CWE111_Unsafe_JNI__console_01_bad",
	"CWE600_Uncaught_Exception_in_Servlet__getParameter_01_bad",
	"OWASP_00196"
	};

	public static String[] filterList = FilterList.lastRunFalseNegatives;
	/**
	 * @param testcases
	 * @return a list of unique testcases. 
	 * testcases that only differ in control flow but not in behavior are grouped heuristically.
	 */
	static ArrayList<TestCase> thinoutTestCases(List<TestCase> testcases) {
		LinkedHashMap<String, TestCase> cases = new LinkedHashMap<>();
		
		for (TestCase t : testcases) {
			if (!t.exploitable)
				continue;
			if (t.key.startsWith("CWE")) {
				cases.put(t.key.replaceAll("[0-9]+", "X"), t);
			} else if (t.key.startsWith("OWASP")){
				cases.put("OWASP" + t.attackPatternId + t.key.charAt(10), t);
			}
				
			
		}
		return new ArrayList<>(cases.values());
		
	}
	static List<TestCase> filterTestcases(List<TestCase> testcases) {
		if (CreateExploitsApp.filterList == null) {
			return testcases;
		}
		HashSet<String> filter = new HashSet<String>(Arrays.asList(CreateExploitsApp.filterList));
		return testcases.stream().filter((cas) -> (filter.contains(cas.key))).collect(Collectors.toList());
		
	}
	
	static List<TestCase> filterNotExploitables(List<TestCase> cases) {
		return cases.stream().filter(t -> t.exploitable).collect(Collectors.toList());
	}

	@SuppressWarnings("unchecked")
	public static <T> Stream<T> filterType(Stream<? super T> str, Class<T> type) {
		return str.filter(s -> (type.isAssignableFrom(s.getClass()))).map(type::cast);
	}

	public static void main(String[] args) throws Exception {
		// FileUtils.deleteDirectory(dockercontainerParentDir);
		Presets ppresets = ParseModels.loadPresets();
		List<TestCase> testcases = ParseModels.parseTestCases();
		testcases = filterNotExploitables(testcases);
		testcases = filterTestcases(testcases);
		//testcases = thinoutTestCases(testcases);
		
		int a = 0;
		int worker_count = -1;
		int worker_id = -1;
		for (String s : args) {
			
			switch (s.toLowerCase()) {
			case "--strict":
				// Fail if anything goes wrong
				strict = true;
				break;
			case "--worker_count":
				worker_count = Integer.parseInt(args[a+1]);
				break;
			case "--worker_id":
				worker_id = Integer.parseInt(args[a+1]);
				break;
				
			}
			a++;
		}
		
		if (worker_count != -1 && worker_id != -1) {
			List<TestCase> newTestcases = new ArrayList<>();
			for (int tc = worker_id; tc < testcases.size(); tc += worker_count) {
				newTestcases.add(testcases.get(tc));
			}
			testcases = newTestcases;
		}
		final int testcaseCount = testcases.size();
		AtomicInteger counter = new AtomicInteger(0);
		final int worker_id_final = worker_id;
		ParallelBase.NonParallelFor(testcases, new ParallelOperation<TestCase>() {

			@Override
			public boolean perform(TestCase t, int progress, int max) {
				try {
					createTestcase(ppresets, t);
					System.out.println(String.format("Worker %d: completed %d / %d containers",worker_id_final, counter.incrementAndGet(), testcaseCount));
				} catch (Exception e) {
					hasError(e);
				}
				return false;
			}
		});
	}

	private static void hasError(Exception exception) {
		exception.printStackTrace();
		if (strict)
			System.exit(1);
	}

	private static String replaceJavax(String src, boolean isJakarta) {
		if (isJakarta) {
			return src.replace("javax.servlet", "jakarta.servlet");
		}
		return src;
	}

	private static void copyFile(Path source, Path destination, boolean jakarta, Map<String,String> jdbcConnectorReplace)
			throws IOException {
		String c = Files.readString(source);
		c = replaceJavax(c, jakarta);

		if (jdbcConnectorReplace != null) {
			for (Entry<String, String> replace : jdbcConnectorReplace.entrySet()) {
				c = c.replace(replace.getKey(), replace.getValue());
			}
			
		}
		Files.writeString(destination, c, StandardOpenOption.CREATE);
	}
	
	 private static String nodeToString(Node node) {
	    StringWriter sw = new StringWriter();
	    try {
	      Transformer t = TransformerFactory.newInstance().newTransformer();
	      t.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
	      t.setOutputProperty(OutputKeys.INDENT, "yes");
	      t.transform(new DOMSource(node), new StreamResult(sw));
	    } catch (TransformerException te) {
	      System.out.println("nodeToString Transformer Exception");
	    }
	    return sw.toString();
	}

	private static void createTestcase(Presets ppresets, TestCase t) throws IOException, Exception {

		System.out.println("Processing " + t.key);

		String pckg = "de.fraunhofer.sit.generatedexploits." + t.testsuite.getName();
		AttackPattern attackPattern = ppresets.getPattern(t.attackPatternId);
		
		for (AttackPatternPreset attackPreset : attackPattern.presets) {
		for (ExecutionProfile executionProfile : t.executionProfileProvider.getExecutionProfileVariants(t)) {
			boolean jakarta = false;
			if (executionProfile instanceof ServletExecutionProfile) {
				jakarta = ((ServletExecutionProfile) executionProfile).convertJavaxToJakarta();
			}
			InputDataAssignment environment = new InputDataAssignment();
			environment.addParameter("Host", "testcase");
			for (Entry<String, String> param : executionProfile.getParameters().entrySet()) {
				environment.addParameter(param.getKey(), param.getValue());
			}
			environment.addParameter("file", "/tmp/textfile.txt");
			environment.addParameter("TestKey", t.key);

			List<File> classpathLibs = executionProfile.getClasspath();

			String clName = t.key.substring(t.key.lastIndexOf(".") + 1) + "_" + attackPreset.id + "_" + executionProfile.getName();
			System.out.println("processing " + clName);
			String fullyQualified = pckg + "." + clName;

			File containerDir = new File(dockercontainerParentDir, clName);
			containerDir.mkdirs();

			Files.writeString(new File(containerDir, "model.xml").toPath(), nodeToString(t.sourceNode));
			File classesDestination = executionProfile.getClassesTargetDirectory(containerDir);

			classpathLibs.add(classesDestination);

			environment.addParameter("testcaseclass", fullyQualified);
			CodeGenerator generator = new CodeGenerator(t, executionProfile, attackPreset, environment, clName);
			GeneratedCode ct = generator.generate();

			File f = new File(classesDestination, fullyQualified.replace('.', '/') + ".java");
			f.getParentFile().mkdirs();

			// copy additional files
			for (Entry<String, String> additionalFile : executionProfile.getAdditionalFiles().entrySet()) {
				File file = new File(containerDir, additionalFile.getKey());
				file.getParentFile().mkdirs();
				FileUtils.write(file, additionalFile.getValue());
			}
			// copy additional classes
			for (Entry<String, String> additionallClass : executionProfile.getAdditionalClasses().entrySet()) {

				File dstFile = new File(classesDestination, additionallClass.getKey().replace('.', '/') + ".java");

				dstFile.getParentFile().mkdirs();
				FileUtils.write(dstFile, additionallClass.getValue());
			}
			// copy testcase sources

			for (TestCaseSource c : t.sources) {
				File destination = new File(classesDestination, c.pckg.replace('.', '/'));
				destination.mkdirs();
				for (File src : c.getFiles()) {
					Map<String, String> replace = new HashMap<>();
					File dstFile = new File(destination, src.getName());
					String jdbcConnectorReplace = null;
					// TODO
					if (dstFile.getName().equals("IO.java")) {
						Optional<DatabaseInput> dbinput = filterType(t.inputs.stream(), DatabaseInput.class)
								.findFirst();
						Optional<DatabaseOutput> dboutput = filterType(t.outputs.stream(), DatabaseOutput.class)
								.findFirst();
						if (dbinput.isPresent()) {
							replace.put("private static final String dbUrl = \"\";",
									"private static final String dbUrl = \"" + dbinput.get().connection + "\";");
						} else if (dboutput.isPresent()){

							replace.put("private static final String dbUrl = \"\";",
									"private static final String dbUrl = \"" + dboutput.get().connection + "\";");
						}
						
					}
					
					replace.put("conn.setAutoCommit(false);", "conn.setAutoCommit(true);");
					replace.put("org.owasp.benchmark.helpers.Utils.commonHeaders.contains(name)", "org.owasp.benchmark.helpers.Utils.commonHeaders.contains(name.toLowerCase())");
					if (t.testsuite instanceof JulietTestsuite) {
						replace.put("ldap://localhost:389",
								"ldap://localhost:10389");
						replace.put("directoryContext.search(\"\"", "directoryContext.search(\"ou=users,ou=system\"");
					}

					copyFile(src.toPath(), dstFile.toPath(), jakarta, replace);
				}
			}

			// copy libs

			List<String> jars = new ArrayList<>();

			Path libDir = new File(containerDir, "lib").toPath();
			libDir.toFile().mkdirs();
			for (File cpentry : executionProfile.getClasspath()) {
				String name = cpentry.getName();
				jars.add(name);
				Files.copy(cpentry.toPath(), libDir.resolve(name), StandardCopyOption.REPLACE_EXISTING);
			}

			// start compiling

			// check classpath
			for (File lib : classpathLibs) {
				if (!lib.exists()) {
					throw new RuntimeException("Couldn't find lib " + lib);
				}
			}

			// compile sources
			for (TestCaseSource c : t.sources) {
				File destination = new File(classesDestination, c.pckg.replace('.', '/'));
				for (File src : c.getFiles()) {
					File dstFile = new File(destination, src.getName());

					compile(dstFile, classpathLibs);
				}
			}

			// compile exploit
			String waitForServices = "";
			if (t.attackPatternId.equals("LDAPInjection")) {
				waitForServices += "new java.net.Socket(\"localhost\", 10389).close();\n";
			}
			if (t.attackPatternId.equals("SQLInjection") || t.inputs.stream().anyMatch(i -> (i instanceof DatabaseInput) || t.outputs.stream().anyMatch(o -> (o instanceof DatabaseOutput)))) {
				waitForServices += "new java.net.Socket(\"localhost\", 9001).close();\n";
			}
			if (waitForServices.isEmpty()) {
				waitForServices = "// no services required";
			}
			ct.content = ct.content.replace("/* WAITFORSERVICES */", waitForServices);
			compileCode(ct.content, pckg, f, classpathLibs);
			for (Entry<String, String> additionallClass : executionProfile.getAdditionalClasses().entrySet()) {
				String helperClassPckg = t.key.substring(t.key.lastIndexOf(".") + 1);
				f = new File(classesDestination, additionallClass.getKey().replace('.', '/') + ".java");
				f.getParentFile().mkdirs();
				String source = replaceJavax(additionallClass.getValue(), jakarta);

				Files.writeString(f.toPath(), source);
				compile(f, classpathLibs);
			}

			// compile helper classes
			for (String helperClass : ct.helperClasses) {
				String helperPackage = "de.fraunhofer.sit.testcodehelpers." + t.testsuite;

				String qualifiedName = helperPackage + "." + getClassName(helperClass);

				f = new File(classesDestination, qualifiedName.replace('.', '/') + ".java");
				f.getParentFile().mkdirs();

				compileCode(replaceJavax(helperClass, jakarta), helperPackage, f, classpathLibs);
			}

			// generate dockerfile
			File dockerFile = new File(containerDir, "Dockerfile");

			FileWriter dockerfileFW = new FileWriter(dockerFile);

			dockerfileFW.write("FROM openjdk:11\n" + "COPY . /usr/src/poc\n" + "WORKDIR /usr/src/poc\n");

			File classDirectoryInContainer = executionProfile.getClassesTargetDirectory(new File("/usr/src/poc"));
			String libDirInContainer = "/usr/src/poc/lib/";

			String classpathInContainer = classDirectoryInContainer.toString();

			for (String jar : jars) {
				classpathInContainer += ":" + libDirInContainer + jar;
			}

			File startsh = new File(containerDir, "start.sh");

			try (FileWriter startshFW = new FileWriter(startsh)) {
				startshFW.write("# This script should be run in the docker container. \n");
				startshFW.write("# docker build . -t juliet;docker run --cap-add NET_ADMIN  juliet\n");

				// find out which hosts to map
				// thankfully no ports have to be exposed, as all traffic happens inside the
				// network
				Set<String> mapHostnameToExploit = new HashSet<>();
				Set<String> mapHostnameToTestcase = new HashSet<>();
				mapHostnameToTestcase.add("testcase");
				// testcase opens socket at address
				filterType(t.inputs.stream(), ConnectToRemoteSocket.class).forEach(read -> {
					mapHostnameToExploit.add(read.host);
				});
				filterType(t.outputs.stream(), WriteToRemoteSocket.class).forEach(write -> {
					mapHostnameToExploit.add(write.host);
				});

				// testcase reads from url
				filterType(t.inputs.stream(), ReadFromURL.class).forEach(read -> {
					mapHostnameToExploit.add(read.host);
				});

				// testcase opens serversocket
				filterType(t.inputs.stream(), OpenServerSocket.class).forEach(read -> {
					mapHostnameToTestcase.add(read.host);
				});

				filterType(t.outputs.stream(), ExecutesBinary.class).forEach(x -> {
					try {
						// the string passed to Runtime.exec() is NOT absolute on unix paths
						// as such, it has to be on the system path
						// we could also put our binary in /bin...
						startshFW.append("export PATH=$PATH:$(pwd)\n");
						String escapedBinaryPath = x.binarypath.replace("\\", "\\\\");
						startshFW.write(String.format("echo \"#!/bin/bash\" > %s \n", escapedBinaryPath));
						startshFW.write(String.format("echo \"echo hello\" >> %s \n", escapedBinaryPath));
						startshFW.write(String.format("echo \"echo hello > /canary.txt\" >> %s \n", escapedBinaryPath));
						startshFW.write(String.format("chmod +x %s\n", escapedBinaryPath));
					} catch (IOException e) {
						throw new RuntimeException(e);
					}
				});

				filterType(t.inputs.stream(), LoadLibrary.class).findFirst().ifPresent(ll -> {
					try {
						startshFW.append("apt-get update\n");
						startshFW.append("apt-get -y install gcc\n");
						startshFW.append(
								"gcc -shared -Wall -Werror -I/usr/local/openjdk-11/include/ -I/usr/local/openjdk-11/include/linux -o libtest.dll.so -fPIC Exploit.c\n");
						startshFW.append("cp libtest.dll.so /lib/libtest.dll.so\n");
						startshFW.append("cp libtest.dll.so /lib/" + ll.path + "\n");
						Path exploitC = Paths.get("../Native/Exploit.c");
						Files.copy(exploitC, new File(containerDir, "Exploit.c").toPath(),
								StandardCopyOption.REPLACE_EXISTING);

					} catch (IOException e) {
						throw new RuntimeException(e);
					}
				});

				String fakeHost = null;

				startshFW.write("MYIP=$(hostname --all-ip-addresses) \n");
				startshFW.write("echo my ip: \n");
				startshFW.write("echo $MYIP \n");

				filterType(t.outputs.stream(), WriteToServerSocket.class).forEach(write -> {
					mapHostnameToTestcase.add(write.host);
					if (write.fakehostname != null && write.fakeipaddress == null) {
						throw new RuntimeException("fakehostname is only allowed with an arbitrary fake ip address.");
						// TODO: this can't happen more than once...

					} else if (write.fakeipaddress != null) {
						try {
							startshFW.write("apt-get update\n");
							startshFW.write("apt-get -y install iptables net-tools\n");

							// startshFW.write("sysctl -w net.ipv4.conf.all.route_localnet=1\n");
							startshFW.write("iptables -v -t nat -A POSTROUTING -p tcp -d $MYIP --dport " + write.port
									+ " -j SNAT --to-source " + write.fakeipaddress + "\n");
							if (write.fakehostname != null) {
								startshFW.write(String.format("echo %s %s > /etc/hosts\n", write.fakeipaddress,
										write.fakehostname));
							}
						} catch (IOException e) {
							e.printStackTrace();
							throw new RuntimeException(e);

						}

					}
				});

				if (mapHostnameToExploit.size() > 0 || mapHostnameToTestcase.size() > 0) {
					mapHostnameToExploit.forEach(h -> {
						try {
							startshFW.write(String.format("echo 127.0.0.1 %s >> /etc/hosts\n", h));
						} catch (IOException e1) {
							// TODO Auto-generated catch block
							e1.printStackTrace();
						}
					});
					mapHostnameToTestcase.forEach(h -> {
						try {
							startshFW.write(String.format("echo $MYIP %s >> /etc/hosts\n", h));
						} catch (IOException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					});

				}
				if (t.testsuite instanceof OWASPTestsuite) {
					startshFW.write("chmod +x /usr/src/poc/insecureCmd.sh\n");

				}
				startshFW.write("echo \"textfilecontents123\\n\" > /tmp/textfile.txt\n");
				startshFW.write("mkdir -p /home/user/uploads\n");
				startshFW.write("mkdir -p /usr/src/poc/testfiles\n");
				startshFW.write(String.format("java \\\n-cp \\\n%s \\\n%s\n", classpathInContainer, fullyQualified));

				// dockerfileFW.write("\nEXPOSE 8082\n");

			}

			dockerfileFW.write("CMD sh /usr/src/poc/start.sh\n");
			dockerfileFW.close();
			File info = new File(containerDir, "information");
			try (FileWriter infoFW = new FileWriter(info)) {
				infoFW.write("AttackPreset=" + attackPreset.id + "\n");
				infoFW.write("TestSuite=" + t.testsuite.getName() + "\n");
				infoFW.write("Key=" + t.key + "\n");
				infoFW.write("DateCreated=" + new Date() + "\n");
				infoFW.write("ExecutionProfile="+executionProfile.getName()+"\n");
			}

			System.out.println("Processed " + t.key + " - " + attackPreset.id + " - " + executionProfile);
			}
		}
	}

	private static String getClassName(String source) {
		Pattern p = Pattern.compile("class ([A-Za-z0-9_]+)");
		Matcher m = p.matcher(source);
		m.find();
		try {
			return m.group(1);
		} catch (IndexOutOfBoundsException e) {
			throw new RuntimeException("failed to get class name from source");
		}
	}

	private static String getCPArg(List<File> classpathLibs) {
		String cp = "/usr/src/poc:" +  testCodeSrcDir + ":" + vulnerableCodeSrcDir;
		for (File s : classpathLibs) {
			cp += ":" + s.getPath();
		}
		return cp;
	}

	private static void compile(File f, List<File> classpathLibs) {
		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();

		compiler.run(null, null, null, f.getAbsolutePath(), "-cp", getCPArg(classpathLibs), "-target", "11", "-source",
				"11", "-nowarn");

		File cl = new File(f.getParent(), f.getName().replace(".java", ".class"));
		if (!cl.exists()) {
			throw new RuntimeException(cl + " does not exist");
		}
	}

	private static void compileCode(String source, String packageName, File f, List<File> classpath) throws Exception {

		try (PrintWriter w = new PrintWriter(f)) {
			w.append("package " + packageName + ";\n\n");
			w.append(source);
		}

		compile(f, classpath);

	}

}
