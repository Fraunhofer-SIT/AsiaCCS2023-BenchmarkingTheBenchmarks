package de.fraunhofer.sit.specifications.attackoutputs;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.Inet4Address;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Phaser;

import org.w3c.dom.Node;

import de.fraunhofer.sit.specifications.attackinputs.Input;
import de.fraunhofer.sit.specifications.attackinputs.InputParameter;
import de.fraunhofer.sit.specifications.attackinputs.ReadFromRemoteSocket.Template;
import de.fraunhofer.sit.specifications.codegen.CodeGenerator;
import de.fraunhofer.sit.specifications.codegen.ITakesParameters;
import de.fraunhofer.sit.specifications.testcases.TestCase;
import de.fraunhofer.sit.specifications.util.XMLUtils;

public class WriteToRemoteSocket extends OutputAsync implements ITakesParameters {
	public String host;
	public int port;
	public String destination;	
	public  class Template {
		static Phaser attackFinished;
		static ServerSocket server;
		static String programOutput;
		static void processOutput(int port) throws IOException {
			
			
			System.out.println("[WRITETOREMOTESOCKET] Opening socket on port " + port);

			server = new ServerSocket(port);
			server.setSoTimeout(4000);
			
			new Thread() {
				private void collectOutput() throws Exception {
					Socket socket = server.accept();			
					System.out.println("[WRITETOREMOTESOCKET] testcase accepted. Reading data ");
					System.out.println("[STDOUT] collecting stdout... ");

					InputStream i = socket.getInputStream();
					BufferedReader b = new BufferedReader(new InputStreamReader(i));
					String line = null;
					while((line = b.readLine()) != null) {
						programOutput += line;
					}
					
				}
				@Override
				public void run() {
					
					try {
						collectOutput();
					} catch (Exception e) {
						e.printStackTrace();
					}
					System.out.println("[WRITETOREMOTESOCKET] finished collecting output. output: \n" + programOutput + "\n[WRITETOREMOTESOCKET] end of output");
					attackFinished.arriveAndDeregister();
					
				}
			}.start();
			
		}
	}
	
	@Override
	public void generateCode(TestCase testcase, CodeGenerator generator) {
		generator.merge(Template.class, getFieldRenames());
	}

	@Override
	public String getTagName() {
		return "WriteToRemoteSocket";
	}

	@Override
	public void readIn(Node node) {
		host = XMLUtils.getAttributeValue(node, "host");
		port = Integer.valueOf(XMLUtils.getAttributeValue(node, "port"));
		destination = XMLUtils.getAttributeValue(node, "destination", "programOutput");
	}
	
	@Override
	public Map<String, String> getFieldRenames() {
		Map<String,String> renames = new HashMap<>();
		renames.put("programOutput", destination);
		renames.put("server", "server");
		return renames;
	}

	@Override
	public List<Object> getParameterValues() {
		List <Object> l = new ArrayList<>();
		l.add(port);
		return l;
	}

	@Override
	public Input getTriggeringInput(List<Input> inputs) {
		// null means no input. this output should start listening immediately.
		return null;
	}


}
