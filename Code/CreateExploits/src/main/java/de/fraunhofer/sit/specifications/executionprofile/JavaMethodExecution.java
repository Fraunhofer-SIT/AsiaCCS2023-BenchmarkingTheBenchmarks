package de.fraunhofer.sit.specifications.executionprofile;

import java.io.File;
import java.io.IOException;
import java.lang.ProcessBuilder.Redirect;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.w3c.dom.Node;

import de.fraunhofer.sit.specifications.attackinputs.Input;
import de.fraunhofer.sit.specifications.attackoutputs.DummyDatabaseCredentialsOutput;
import de.fraunhofer.sit.specifications.codegen.CodeGenerator;
import de.fraunhofer.sit.specifications.testcases.TestCase;
import de.fraunhofer.sit.specifications.util.MavenDependencyUtils;
import de.fraunhofer.sit.specifications.util.XMLUtils;
import spoon.Launcher;
import spoon.reflect.declaration.CtClass;

public class JavaMethodExecution extends ExecutionProfile implements ExecutionProfileProvider {

	@Override
	public String getName() {
		return "MethodExec";
	}
	
	@Override
	public List<ExecutionProfile> getExecutionProfileVariants(TestCase tc) {
		return Arrays.asList(new JavaMethodExecution(tc, classname, methodname, processid));
	}

	
	public JavaMethodExecution(TestCase tc, String classname, String methodname, String processid) {
		super(tc);
		this.classname = classname;
		this.methodname = methodname;
		this.processid = processid;
	}
	public JavaMethodExecution() {
		super(null);
	}

	String classname;
	String methodname;
	//String[] arguments;
	String processid;
	
	@Override
	public String getTagName() {
		return "JavaMethodExecution";
	}

	@Override
	public Map<String, String> getFieldRenames() {
		Map<String, String> renames = new HashMap();
		renames.put("process_x", processid);
		renames.put("environment", "environment");
		return renames;
	}
	
	@Override
	public void readIn(Node node) {
		classname = XMLUtils.getAttributeValue(node, "classname");
		methodname = XMLUtils.getAttributeValue(node, "methodname");
		processid = XMLUtils.getAttributeValue(node, "processid");
	}

	@Override
	public List<Object> getParameterValues() {
		List<Object> params = new ArrayList<>();
		params.add(classname);
		params.add(methodname);
		return params;
	}



	@Override
	public Map<String, String> getAdditionalFiles() {
		return super.getAdditionalFiles();
	}



	@Override
	public Map<String, String> getAdditionalClasses() {
		Map<String, String> cls = super.getAdditionalClasses();
		
		String[] classNameSplit = classname.split("\\.");
		String name = "de.fraunhofer.sit.testcodehelpers.MethodExecutor";
		String code = "";
		if (testcase.outputs.stream().anyMatch((o)-> (o instanceof DummyDatabaseCredentialsOutput))) {
			code += "Class.forName(\"de.fraunhofer.sit.runexploits.database.JulietDummyDriver\");\n";
		}
		//code += "new de.fraunhofer.sit.runexploits.environment.OWASPEnvironment();\n";
		String methodExecutorClassString = "package de.fraunhofer.sit.testcodehelpers;\n"
				+ "public class MethodExecutor {\n"
				+ "		\n"
				+ "		public static void main(String[] args) throws Throwable {\n"
				+ "			%s"
				+ "			new %s().%s();\n"
				+ "		}\n"
				+ "	}";
		
		String executorClass = String.format(methodExecutorClassString, code, classname, methodname, classname, methodname);
		
		
		cls.put(name, executorClass);
		
		return cls;
	}



	@Override
	public File getClassesTargetDirectory(File root) {
		return new File(root, "bin");
	}

	@Override
	public List<File> getClasspath() {
		// this execution profile is only used by juliet testcases, which sometimes depend on jetty libraries...
		List<File> cp = new ArrayList<>();
		cp.addAll(super.getClasspath());
		try {
			cp.add(MavenDependencyUtils.downloadMavenArtifact("org.slf4j","slf4j-api","1.7.36"));
			cp.add(MavenDependencyUtils.downloadMavenArtifact("org.slf4j","slf4j-simple","1.7.36"));
			cp.add(MavenDependencyUtils.downloadMavenArtifact("org.jsoup","jsoup","1.13.1"));
			cp.add(MavenDependencyUtils.downloadMavenArtifact("org.xerial","sqlite-jdbc","3.34.0"));
			cp.add(MavenDependencyUtils.downloadMavenArtifact("org.eclipse.jetty", "jetty-util", "11.0.8"));
            cp.add(MavenDependencyUtils.downloadMavenArtifact("org.eclipse.jetty", "jetty-xml", "11.0.8"));
            cp.add(MavenDependencyUtils.downloadMavenArtifact("org.eclipse.jetty", "jetty-webapp", "11.0.8"));
            cp.add(MavenDependencyUtils.downloadMavenArtifact("org.eclipse.jetty", "jetty-server", "11.0.8"));
            cp.add(MavenDependencyUtils.downloadMavenArtifact("org.eclipse.jetty", "jetty-servlet", "11.0.8"));
            cp.add(MavenDependencyUtils.downloadMavenArtifact("org.eclipse.jetty", "jetty-security", "11.0.8"));
            cp.add(MavenDependencyUtils.downloadMavenArtifact("org.eclipse.jetty.toolchain", "jetty-servlet-api", "4.0.6"));
            cp.add(MavenDependencyUtils.downloadMavenArtifact("org.eclipse.jetty", "jetty-io", "11.0.8"));
            cp.add(MavenDependencyUtils.downloadMavenArtifact("org.eclipse.jetty", "jetty-http", "11.0.8"));
            cp.add(MavenDependencyUtils.downloadMavenArtifact("org.eclipse.jetty.toolchain", "jetty-jakarta-servlet-api", "5.0.2"));
			cp.addAll(MavenDependencyUtils.downloadMavenDependenciesFromProject(new File("../RunExploits/servletcontainerpoms/cmdline")));
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
		return cp;
		
	}

	class Template {
		public static void startEnvironment() {
			try {
				Class.forName("de.fraunhofer.sit.runexploits.environment.OWASPEnvironment").getDeclaredConstructor().newInstance();
				
				System.out.println("waiting for sevices to go up...");
				while (true) {
					try {
						Thread.sleep(2000);
						// ldap
						new Socket("localhost", 10389).close();
						// hsqldb
						new Socket("localhost", 9001).close();
						break;
					} catch (Exception e) {
						// keep waiting
						
					}
				}
				System.out.println("services are up...");
			} catch (Exception e) {
				throw new RuntimeException(e);
			}
		}
	}
	@Override
	public void generateCode(TestCase testcase, CodeGenerator generator) {
		generator.merge(Template.class, new HashMap<>());
	}
	@Override
	public Map<String, String> getParameters() {
		Map<String, String> params = new HashMap<>();
		return params;
	}
}
