package de.fraunhofer.sit.specifications.attackoutputs;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.Inet4Address;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.w3c.dom.Node;

import de.fraunhofer.sit.specifications.attackoutputs.WriteToRemoteSocket.Template;
import de.fraunhofer.sit.specifications.codegen.CodeGenerator;
import de.fraunhofer.sit.specifications.codegen.ITakesParameters;
import de.fraunhofer.sit.specifications.testcases.TestCase;
import de.fraunhofer.sit.specifications.util.XMLUtils;

/**
 * The testcode starts a {@code new ServerSocket} and writes to it.
 * The exploit must start a Socket and listen. The environment is responsible for routing.
 * @author naeumann
 *
 */
public class WriteToServerSocket extends Output implements ITakesParameters {
	public String host;
	public int port;
	private String destination;
	public String fakehostname;
	public String fakeipaddress;
	
	public  class Template {
		static Socket socket;
		static String programOutput;
		static void processOutput(String host, int port, String fakeipaddress) throws IOException {
			

			Iterator<NetworkInterface> asIterator = NetworkInterface.getNetworkInterfaces().asIterator() ;
			 while (asIterator.hasNext()) {
				    NetworkInterface networkInterface = asIterator.next();
		            System.out.println("[WRITETOSERVERSOCKET] interface " + networkInterface );

				    Enumeration<InetAddress> inetAddress = networkInterface.getInetAddresses();
				    InetAddress currentAddress;
				    currentAddress = inetAddress.nextElement();
				    while(inetAddress.hasMoreElements())
				    {
				        currentAddress = inetAddress.nextElement();
			            System.out.println("[WRITETOSERVERSOCKET] " + networkInterface + " address " + currentAddress);

				        if(currentAddress instanceof Inet4Address && !currentAddress.isLoopbackAddress())
				        {
				            String ip = currentAddress.toString();
				            System.out.println("[WRITETOSERVERSOCKET] " + networkInterface + " ip " + ip);
				            break;
				        }
				    }

			 }
			
			System.out.println("[WRITETOSERVERSOCKET]Reading data from " + host + ":" + port);

			//if (fakeipaddress == null) {
				socket = new Socket(host, port);
			//} else {
			//	System.out.println("[WRITETOSERVERSOCKET] local source address to " + fakeipaddress);
			//	socket = new Socket(host, port, InetAddress.getByName(fakeipaddress), port + 1234);
			//}
			InputStream i = socket.getInputStream();
			BufferedReader b = new BufferedReader(new InputStreamReader(i));
			String line = null;
			while((line = b.readLine()) != null) {
				programOutput += line;
				System.out.println("[WRITETOSERVERSOCKET] " + line);
			}
		}
	}
	
	@Override
	public void generateCode(TestCase testcase, CodeGenerator generator) {
		generator.merge(Template.class, getFieldRenames());
	}

	@Override
	public String getTagName() {
		return "WriteToServerSocket";
	}
	@Override
	public Map<String, String> getFieldRenames() {
		Map<String,String> renames = new HashMap<>();
		renames.put("socket", "socket");
		renames.put("programOutput", destination);
		
		return renames;
	}

	@Override
	public void readIn(Node node) {
		port = Integer.valueOf(XMLUtils.getAttributeValue(node, "port"));
		destination = XMLUtils.getAttributeValue(node, "destination", "programOutput");
		fakehostname = XMLUtils.getAttributeValue(node, "fakehostname", null);
		fakeipaddress = XMLUtils.getAttributeValue(node, "fakeipaddress", null);
		host = "testcase";
	}

	@Override
	public List<Object> getParameterValues() {
		List <Object> l = new ArrayList<>();
		l.add(host);
		l.add(port);
		l.add(fakeipaddress);
		return l;
	}

}
