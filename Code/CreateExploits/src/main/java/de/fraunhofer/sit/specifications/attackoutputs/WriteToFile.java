package de.fraunhofer.sit.specifications.attackoutputs;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.StringWriter;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.Phaser;

import org.w3c.dom.Node;

import de.fraunhofer.sit.specifications.codegen.CodeGenerator;
import de.fraunhofer.sit.specifications.codegen.ITakesParameters;
import de.fraunhofer.sit.specifications.testcases.TestCase;
import de.fraunhofer.sit.specifications.util.XMLUtils;

public class WriteToFile extends Output implements ITakesParameters {
	public String id;
	public String path;
	public String destination;
	public boolean loadcontents;
	public  class Template {
		

		static Phaser attackFinished;
		static String programOutput;
		static boolean fileExists;
		static long filesize = -1;
		
		static void processOutput(String file, boolean loadcontents) throws Exception {
			attackFinished.register(); 
			new Thread() {
				private void collectOutput() throws Exception {
					fileExists = false;
					int tries = 0;
					Path path = Paths.get(file);
					System.out.println(String.format("[WRITETOFILE] looking for %s", path.toString()));
					while (!path.toFile().exists()) {
						Thread.sleep(1000);
						path = Paths.get(file);
						tries++;
						if (tries > 10) {
							break;
						}
					}
					
					fileExists = path.toFile().exists();
					
					if (!fileExists) {
						System.out.println(String.format("[WRITETOFILE] file does not exist: %s ", path));
						return;
					}
					if (loadcontents) {
						String contents = Files.readString(path);
						System.out.println("[WRITETOFILE] got file contents: " + contents);
			        	programOutput = contents;
					}
		        	filesize = Files.size(path);
		        	System.out.println(String.format("[WRITETOFILE] %s file size: %d ", path, filesize));
				}
				@Override
				public void run() {
					
					try {
						collectOutput();
					} catch (Exception e) {
						e.printStackTrace();
					}
					System.out.println("[STDOUT] finished collecting stdout. output: \n" + programOutput + "\n[STDOUT] end of output");
					attackFinished.arriveAndDeregister();
					
				}
			}.start();
			
		}
		
	}
	
	@Override
	public void generateCode(TestCase testcase, CodeGenerator generator) {
		generator.merge(Template.class, getFieldRenames());
	}
	@Override
	public Map<String, String> getFieldRenames() {
		Map<String, String> renames = new HashMap();
		renames.put("programOutput", destination);
		renames.put("fileExists", id + "_exists");
		renames.put("filesize", id + "_size");
		return renames;
	}
	@Override
	public List<Object> getParameterValues() {
		List<Object> params = new ArrayList<>();
		params.add(path);
		params.add(loadcontents);
		return params;
	}
	@Override
	public String getTagName() {
		return "WriteToFile";
	}
	
	@Override
	public void readIn(Node node) {
		path = XMLUtils.getAttributeValue(node, "path");
		id = XMLUtils.getAttributeValue(node, "id", "file");
		destination = XMLUtils.getAttributeValue(node, "destination", "programOutput");
		loadcontents = Boolean.valueOf(XMLUtils.getAttributeValue(node, "loadcontents", "true"));
	}

}
