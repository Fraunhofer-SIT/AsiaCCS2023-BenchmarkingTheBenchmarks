package de.fraunhofer.sit.specifications.exploitcheckers;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.w3c.dom.Node;

import de.fraunhofer.sit.specifications.codegen.CodeGenerator;
import de.fraunhofer.sit.specifications.codegen.IGenerateCode;
import de.fraunhofer.sit.specifications.testcases.TestCase;
import de.fraunhofer.sit.specifications.util.IXMLReadable;
import de.fraunhofer.sit.specifications.util.XMLUtils;

public class OutOfMemory extends SuccessfulExploitIndicator {
	public String processid;
	class Template {
		 static Process process;
		 static String programError;
		public static boolean checkOutput() throws Exception {
			int timeout = 10;
			while (process.isAlive()) {
				Thread.sleep(1000);
				
				if (programError.contains("java.lang.OutOfMemoryError")) {
					System.out.println("[OutOfMemory] out of memory stacktrace detected");
					return true;
				}
				timeout--;
				if (timeout < 0) {
					System.out.println("[OutOfMemory] timeout. process has not terminated");
					return false;
				}
			}
			int result = process.exitValue();
			return result != 0;
		}
		
	}
	@Override
	public String getTagName() {
		return "OutOfMemory";
	}

	@Override
	public void readIn(Node node) {
		processid = XMLUtils.getAttributeValue(node, "processid", "process0");
	}

	@Override
	public void generateCode(TestCase testcase, CodeGenerator generator) {
		generator.merge(Template.class, getFieldRenames());
	}

	@Override
	public List<Object> getParameterValues() {
		List<Object> params = new ArrayList<>();
		return params;
	}
	@Override
	public Map<String, String> getFieldRenames() {
		Map<String, String> names = new HashMap<>();
		names.put("process", processid);
		names.put("programError", "programError");
		return names;
	}
}
